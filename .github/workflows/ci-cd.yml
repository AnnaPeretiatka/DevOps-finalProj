name: ci-cd

on: # triggers for this workflow
  push:
    branches:
      - main           # run on every push to main
  workflow_dispatch: {} # run when click "Run workflow" (allows manual runs from Actions tab)

# permissions to request the OIDC token (to assume AWS role) and to read repo
permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REPO: ${{ secrets.ECR_REPO }} # 992382545251.dkr.ecr.us-east-1.amazonaws.com/status_page_ay-repo
  EKS_CLUSTER: ${{ secrets.EKS_CLUSTER }} # status-page-ay-eks
  K8S_NAMESPACE: statuspage
  DB_USER: statuspage
  DB_HOST: status-page-ay-pg.cx248m4we6k7.us-east-1.rds.amazonaws.com
  DB_NAME: statuspage


jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # 1. Checkout repo
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Exchanges GitHub OIDC token for AWS session on the AWS_ROLE_ARN role created by Terraform
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # 3. Install kubectl
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.30.0'

      # 4. Log in to ECR
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # 5. Build the Docker image and push to ECR
      - name: Build & push Docker image
        run: |
          set -euo pipefail
          GIT_SHA=$(git rev-parse --short HEAD)
          IMAGE_URI="${{ env.ECR_REPO }}:${GIT_SHA}"

          echo "Building image: ${IMAGE_URI}"
          docker build -t "${IMAGE_URI}" .

          echo "Pushing image: ${IMAGE_URI}"
          docker push "${IMAGE_URI}"

          docker tag "${IMAGE_URI}" "${{ env.ECR_REPO }}:latest"
          docker push "${{ env.ECR_REPO }}:latest"

          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV
          echo "GIT_SHA=${GIT_SHA}" >> $GITHUB_ENV
      
      # 6. Install Helm
      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.4'

      # 7. Prepare kubeconfig so kubectl/helm can talk to EKS cluster
      - name: Update kubeconfig for EKS
        run: aws eks update-kubeconfig --region "${AWS_REGION}" --name "${EKS_CLUSTER}"

      # 8. Sanity check connectivity
      - name: Sanity check connectivity
        run: |
          kubectl version
          kubectl get ns
          kubectl get nodes -o wide

      # Build a percent-encoded DATABASE_URL at runtime
      - name: Build DATABASE_URL
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          set -euo pipefail
          ENC=$(python - <<'PY'
          import os, urllib.parse
          print(urllib.parse.quote(os.environ["DB_PASSWORD"], safe=""))
          PY
          )
          echo "DATABASE_URL=postgresql://${DB_USER}:${ENC}@${DB_HOST}:5432/${DB_NAME}?sslmode=require" >> $GITHUB_ENV

      - name: Find ACM cert (optional)
        id: acm
        run: |
          set -euo pipefail

          # Build flags conditionally: HTTPS if ACM exists, else HTTP
          if [ "${{ steps.acm.outputs.have_acm }}" = "true" ]; then
            ACM_FLAGS="--set acmArn='${{ steps.acm.outputs.acm_arn }}' --set env.SITE_PROTOCOL=https"
          else
            ACM_FLAGS="--set env.SITE_PROTOCOL=http"
          fi

      # Check and clean up Helm locks
      - name: Check and clean up Helm locks
        run: |
          set -euo pipefail
          RELEASE_NAME="statuspage"
          NAMESPACE="${K8S_NAMESPACE}"
          if kubectl get cm -n "${NAMESPACE}" | grep -q "sh.helm.release.v1.${RELEASE_NAME}"; then
            echo "Cleaning up Helm lock for release ${RELEASE_NAME} in namespace ${NAMESPACE}..."
            kubectl delete cm -n "${NAMESPACE}" "sh.helm.release.v1.${RELEASE_NAME}.v1" || true
          fi

      # 9. Deploy via Helm
      - name: Deploy via Helm (app only)
        env:
          STATUS_HOSTNAME: status-page-ay.com   # the hostname for the status page
          DATABASE_URL: ${{ env.DATABASE_URL }} # from prior step
          ACM_ARN: ${{ secrets.ACM_ARN }}                   # optional; leave blank if not ready
        run: |
          set -euo pipefail

          # Build ALB HTTPS annotations only when ACM_ARN is set
          ACM_FLAGS=""
          if [[ -n "${ACM_ARN:-}" ]]; then
            # Prefer your chart's single knob if you kept .Values.acmArn
            ACM_FLAGS="--set acmArn='${ACM_ARN}' --set env.SITE_PROTOCOL=https"
          else
            ACM_FLAGS="--set env.SITE_PROTOCOL=http"
          fi
          
          #--set ingress.annotations."alb\.ingress\.kubernetes\.io/listen-ports"='\''[{"HTTP":80},{"HTTPS":443}]'\'' \
          #--set ingress.annotations."alb\.ingress\.kubernetes\.io/certificate-arn"="'"${ACM_ARN}"'" \
          #--set ingress.annotations."alb\.ingress\.kubernetes\.io/ssl-redirect"="443"'
          

          set -euo pipefail
          helm upgrade --install statuspage infra/helm/statuspage \
            --namespace "${K8S_NAMESPACE}" \
            --create-namespace \
            --set image.repository="${ECR_REPO}" \
            --set image.tag="${GIT_SHA}" \
            --set image.pullPolicy=Always \
            --set env.SECRET_KEY='${{ secrets.SECRET_KEY }}' \
            --set-string env.DATABASE_URL="${DATABASE_URL}" \
            --set env.REDIS_URL='${{ secrets.REDIS_URL }}' \
            --set env.STATUS_HOSTNAME="${STATUS_HOSTNAME}" \
            --set env.ALLOWED_HOSTS="${STATUS_HOSTNAME}" \
            --set env.SITE_PROTOCOL='https' \
            --set s3.bucket="status-page-ay-statics3-992382545251" \
            --set s3.region='${{ env.AWS_REGION }}' \
            --set ingress.enabled=true \
            --set ingress.className=alb \
            --set ingress.hosts[0].host="${STATUS_HOSTNAME}" \
            --set ingress.hosts[0].paths[0].path=/ \
            --set ingress.hosts[0].paths[0].pathType=Prefix \
            ${ACM_FLAGS} || {
              code=$?
              echo "::error::Helm upgrade failed with exit code $code"
              echo "----- kube events (last 100) -----"
              kubectl -n "${K8S_NAMESPACE}" get events --sort-by=.lastTimestamp | tail -n 100 || true
              echo "----- web pods -----"
              kubectl -n "${K8S_NAMESPACE}" get pods -l app=statuspage,tier=web -o wide || true
              echo "----- web pod logs (last 200 lines) -----"
              for p in $(kubectl -n "${K8S_NAMESPACE}" get pods -l app=statuspage,tier=web -o name || true); do
                echo "### $p"
                kubectl -n "${K8S_NAMESPACE}" logs "$p" --tail=200 || true
              done
              exit $code
            }
          echo "Helm succeeded."






